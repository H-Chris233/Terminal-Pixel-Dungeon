//! Integration tests covering multi-system scenarios
//!
//! These tests verify that multiple systems work together correctly:
//! - Movement + Combat
//! - AI + Status effects
//! - Hunger + Save/Load

mod test_helpers;

use test_helpers::*;
use terminal_pixel_dungeon::ecs::*;
use terminal_pixel_dungeon::systems::*;
use terminal_pixel_dungeon::turn_system::TurnState;

#[test]
fn test_movement_into_combat() {
    // Setup: Player at (5,5), Enemy at (5,6)
    let (builder, enemy) = TestWorldBuilder::new(42)
        .with_simple_dungeon(0)
        .with_player(5, 5, 0)
        .with_enemy(5, 6, 0, "Test Rat", Faction::Enemy);
    
    let mut world = builder.build();
    
    // Verify initial positions
    let player_pos = world.player_position().unwrap();
    assert_eq!(player_pos.x, 5);
    assert_eq!(player_pos.y, 5);
    
    // Move player south (towards enemy)
    world.execute_player_action(PlayerAction::Move(Direction::South));
    
    // Process movement system
    let mut movement_system = MovementSystem;
    movement_system.run(
        &mut world.ecs_world.world,
        &mut world.ecs_world.resources,
    );
    
    // After movement, player should be at (5,6) - same position as enemy
    // This should trigger combat in the combat system
    let new_pos = world.player_position().unwrap();
    
    // Process combat system
    let mut combat_system = CombatSystem;
    combat_system.run(
        &mut world.ecs_world.world,
        &mut world.ecs_world.resources,
    );
    
    // Check that combat occurred (enemy should have taken damage or died)
    let enemy_hp_after = world.entity_stats(enemy).map(|s| s.hp);
    
    // Enemy should have less than full HP or be dead
    assert!(
        enemy_hp_after.is_none() || enemy_hp_after.unwrap() < 50,
        "Enemy should have taken damage from combat"
    );
}

#[test]
fn test_ai_behavior_with_status_effects() {
    // Setup: Enemy with low HP and status effects
    let (builder, enemy) = TestWorldBuilder::new(123)
        .with_simple_dungeon(0)
        .with_player(5, 5, 0)
        .with_enemy(7, 5, 0, "Test Goblin", Faction::Enemy);
    
    let mut world = builder.build();
    
    // Set enemy HP low
    world.set_entity_hp(enemy, 5);
    
    // Add a poison status effect
    // (This would require adding status effects to the entity)
    // For now, we verify the AI can still make decisions with low HP
    
    // Process AI system
    let mut ai_system = AISystem;
    ai_system.run(
        &mut world.ecs_world.world,
        &mut world.ecs_world.resources,
    );
    
    // Enemy should still be functional (didn't crash)
    assert!(world.ecs_world.world.contains(enemy));
}

#[test]
fn test_ai_targeting_player() {
    // Setup: Player and enemy in line of sight
    let (builder, enemy) = TestWorldBuilder::new(456)
        .with_simple_dungeon(0)
        .with_player(5, 5, 0)
        .with_enemy(7, 5, 0, "Test Orc", Faction::Enemy);
    
    let mut world = builder.build();
    
    // Update FOV for the enemy
    let mut fov_system = FOVSystem;
    fov_system.run(
        &mut world.ecs_world.world,
        &mut world.ecs_world.resources,
    );
    
    // Process AI - should target player
    let mut ai_system = AISystem;
    ai_system.run(
        &mut world.ecs_world.world,
        &mut world.ecs_world.resources,
    );
    
    // Check if enemy has player as target
    if let Ok(ai) = world.ecs_world.world.get::<&AI>(enemy) {
        assert!(
            ai.target.is_some() || !ai.path.is_empty(),
            "Enemy should target player or have a path"
        );
    }
}

#[test]
fn test_hunger_system_integration() {
    // Setup: Player with low hunger
    let mut world = TestWorldBuilder::new(789)
        .with_simple_dungeon(0)
        .with_player(5, 5, 0)
        .build();
    
    // Set player hunger to near-starving
    if let Some(player) = world.player_entity() {
        if let Ok(mut hunger) = world.ecs_world.world.get::<&mut Hunger>(player) {
            hunger.current = 50; // Below starving threshold of 100
        }
    }
    
    // Process hunger system
    let mut hunger_system = HungerSystem;
    let result = hunger_system.run(
        &mut world.ecs_world.world,
        &mut world.ecs_world.resources,
    );
    
    // Player should start taking damage from starvation
    // Check message log for hunger warnings
    let messages = &world.ecs_world.resources.game_state.message_log;
    assert!(
        messages.iter().any(|m| m.contains("é¥¿") || m.contains("starv")),
        "Should have hunger-related message"
    );
}

#[test]
fn test_energy_system_turn_cycle() {
    // Setup: Player and enemy
    let (builder, enemy) = TestWorldBuilder::new(111)
        .with_simple_dungeon(0)
        .with_player(5, 5, 0)
        .with_enemy(6, 5, 0, "Test Rat", Faction::Enemy);
    
    let mut world = builder.build();
    
    // Set player energy to 50
    world.set_entity_energy(world.player_entity().unwrap(), 50);
    
    // Process energy system (should regenerate)
    let mut energy_system = EnergySystem;
    energy_system.run(
        &mut world.ecs_world.world,
        &mut world.ecs_world.resources,
    );
    
    // Energy should increase
    let final_energy = world.player_energy().unwrap();
    assert!(final_energy.current > 50, "Energy should regenerate");
}

#[test]
fn test_complete_turn_pipeline() {
    // Test the complete turn pipeline execution order
    let mut world = TestWorldBuilder::new(222)
        .with_simple_dungeon(0)
        .with_player(5, 5, 0)
        .build();
    
    // Set initial energy
    let initial_energy = world.player_energy().unwrap().current;
    
    // Execute a movement action
    world.execute_player_action(PlayerAction::Move(Direction::North));
    
    // Process complete turn
    assert!(world.process_turn().is_ok());
    
    // Verify turn system state changed appropriately
    // Energy should have been consumed and regenerated
    let final_energy = world.player_energy().unwrap();
    
    // After a full turn cycle, energy might be different based on costs
    assert!(final_energy.current <= initial_energy || final_energy.max == final_energy.current);
}

#[test]
fn test_inventory_system_integration() {
    // Setup: Player with an item
    let mut world = TestWorldBuilder::new(333)
        .with_simple_dungeon(0)
        .with_player(5, 5, 0)
        .build();
    
    // Add a potion to player's inventory
    if let Some(player) = world.player_entity() {
        if let Ok(mut inv) = world.ecs_world.world.get::<&mut Inventory>(player) {
            let potion = ECSItem {
                name: "Health Potion".to_string(),
                item_type: ItemType::Consumable(ConsumableEffect::Heal(20)),
                quantity: 1,
            };
            inv.items.push(potion);
        }
    }
    
    // Use the item
    world.execute_player_action(PlayerAction::UseItem(ItemSlot(0)));
    
    // Process inventory system
    let mut inventory_system = InventorySystem;
    inventory_system.run(
        &mut world.ecs_world.world,
        &mut world.ecs_world.resources,
    );
    
    // Check that item was consumed
    if let Some(player) = world.player_entity() {
        if let Ok(inv) = world.ecs_world.world.get::<&Inventory>(player) {
            // Item should be removed or quantity decreased
            assert!(
                inv.items.is_empty() || inv.items[0].name != "Health Potion",
                "Item should be consumed"
            );
        }
    }
}

#[test]
fn test_player_death_scenario() {
    // Setup: Player with very low HP
    let mut world = TestWorldBuilder::new(444)
        .with_simple_dungeon(0)
        .with_player(5, 5, 0)
        .build();
    
    // Set player HP to 1
    world.set_entity_hp(world.player_entity().unwrap(), 1);
    
    // Set hunger to starving (to trigger damage)
    if let Some(player) = world.player_entity() {
        if let Ok(mut hunger) = world.ecs_world.world.get::<&mut Hunger>(player) {
            hunger.current = 0;
        }
    }
    
    // Process hunger system (should kill player)
    let mut hunger_system = HungerSystem;
    hunger_system.run(
        &mut world.ecs_world.world,
        &mut world.ecs_world.resources,
    );
    
    // Check if game is over
    let game_state = &world.ecs_world.resources.game_state.game_state;
    
    // Game should be over or player should be dead
    let player_alive = world.player_entity()
        .and_then(|p| world.entity_stats(p))
        .map(|s| s.hp > 0)
        .unwrap_or(false);
    
    assert!(!player_alive || matches!(game_state, GameStatus::GameOver { .. }));
}

#[test]
fn test_multi_enemy_ai_coordination() {
    // Setup: Player surrounded by multiple enemies
    let (builder, enemy1) = TestWorldBuilder::new(555)
        .with_simple_dungeon(0)
        .with_player(5, 5, 0)
        .with_enemy(4, 5, 0, "Rat 1", Faction::Enemy);
    
    let (builder, enemy2) = builder
        .with_enemy(6, 5, 0, "Rat 2", Faction::Enemy);
    
    let (builder, enemy3) = builder
        .with_enemy(5, 4, 0, "Rat 3", Faction::Enemy);
    
    let mut world = builder.build();
    
    // Update FOV for all entities
    let mut fov_system = FOVSystem;
    fov_system.run(
        &mut world.ecs_world.world,
        &mut world.ecs_world.resources,
    );
    
    // Process AI for all enemies
    let mut ai_system = AISystem;
    ai_system.run(
        &mut world.ecs_world.world,
        &mut world.ecs_world.resources,
    );
    
    // All enemies should have the player as their target
    let enemies = [enemy1, enemy2, enemy3];
    for &enemy in &enemies {
        if let Ok(ai) = world.ecs_world.world.get::<&AI>(enemy) {
            assert!(
                ai.target.is_some(),
                "Enemy should target player"
            );
        }
    }
}

#[test]
fn test_movement_across_multiple_turns() {
    // Test player movement over multiple turns
    let mut world = TestWorldBuilder::new(666)
        .with_simple_dungeon(0)
        .with_player(5, 5, 0)
        .build();
    
    let initial_pos = world.player_position().unwrap();
    
    // Execute a sequence of movements
    TurnSequenceBuilder::new()
        .move_direction(Direction::North)
        .move_direction(Direction::East)
        .move_direction(Direction::South)
        .move_direction(Direction::West)
        .execute(&mut world)
        .expect("Movement sequence failed");
    
    // After moving in a square, player should be back at start
    let final_pos = world.player_position().unwrap();
    assert_eq!(initial_pos.x, final_pos.x);
    assert_eq!(initial_pos.y, final_pos.y);
}

#[test]
fn test_fov_and_stealth_mechanics() {
    // Test that FOV system correctly calculates visibility
    let (builder, enemy) = TestWorldBuilder::new(777)
        .with_simple_dungeon(0)
        .with_player(5, 5, 0)
        .with_enemy(8, 8, 0, "Sneaky Rat", Faction::Enemy);
    
    let mut world = builder.build();
    
    // Process FOV system
    let mut fov_system = FOVSystem;
    fov_system.run(
        &mut world.ecs_world.world,
        &mut world.ecs_world.resources,
    );
    
    // Check player's viewshed
    if let Some(player) = world.player_entity() {
        if let Ok(viewshed) = world.ecs_world.world.get::<&Viewshed>(player) {
            // Player should see some tiles
            assert!(!viewshed.visible_tiles.is_empty(), "Player should see some tiles");
        }
    }
}
